# <p style="background-color: #f5f567">들어가며</p>

## 왜 리액트인가?

**1. 명시적인 상태 변경**

리액트는 단방향 바인딩만 지원한다.

- 단방향 바인딩은 데이터가 흐르는 방향이 한쪽으로만 흐른다는 의미이다.
- 이와 반대되는 용어는 Angular의 양방향 바인딩이다. 양방향으로 바인딩되면 뷰의 변화가 컴포넌트에 영향을 미칠 수도, 반대로 컴포넌트의 상태가 변경되면 뷰의 상태도 변경될 수 있다. 양방향 바인딩은 단방향 바인딩이 제공할 수 없는 편리함을 제공하지만, 복잡한 애플리케이션에서는 데이터의 흐름을 예측하기 어렵게 만들 수 있다.
- 리액트의 상태 변화는 '단방향'으로 그리고 '명시적'으로 이뤄진다. 상태가 변화했다면 그 상태 변화를 명시적으로 일으키는 함수만 찾으면 된다.
  이러한 리액트의 명시적인 상태 업데이트는 많은 개발자들에게 간단함과 유연함을 제공한다.

```javascript
// Angular의 경우 input의 입력으로 name이 변경되거나, AppComponent 클래스 내부에서 직접 name츨 변경할 수 있다.
// name이 변경된 이유를 알고 싶다면 template이나 클래스 내부에서 name을 변경하는 곳을 다 찾아봐야 한다.

import { Component } from "@angular/core";

@Component({
  selector: "app-root",
  template: `<input type="text" [(ngModel)]="name" />`,
})
export class AppComponent {
  name = "";
}
```

```javascript
// 리액트의 경우 name이 변경되는 경우는 setName이 호출될 때뿐이다.
// name이 변경된 이유를 알고 싶다면 setName을 호출하는 곳을 찾아보면 된다.

import React, { useState } from "react";

const App = () => {
  const [name, setName] = useState("");

  function onChange(e) {
    setName(e.target.value);
  }

  return <input type="text" value={name} />;
};
```

단방향 바인딩은 항상 변화를 감지하고 업데이트하는 코드를 매번 작성해야 하며, 이에 따라 코드의 규모가 증가하는 등의 단점이 있다.

여기서 말하고자 하는 단방향 바인딩의 특징은 양방향 바인딩에 비해 데이터의 흐름의 변화가 단순하기 때문에 코드를 읽기가 쉽고 버그를 야기할 가능성이 비교적 적다는 점이다.

**2. JSX(JavaScript XML)**
Angular는 뷰를 표현하기 위해 문자열 템플릿string template를 사용하고, Angular 디렉티브라고하는 ngIf처럼 Angular의 특별한 속성을 사용하여 뷰를 표현한다.
하지만 리액트에서는 HTML에 자바스크립트 문법을 더한 JSX를 사용하는데, 이는 기존에 알고 있는 자바스크립트 문법에 HTML을 약간 가미한 수준이며, 고유의 몇가지 특징만 이해한다면 손쉽게 JSX를 사용할 수 있다.

```javascript
// Angular, 추가적인 *ngIf를 사용해야 한다.
<div *ngIf="condition">Content to render when condition is true</div>
```

```javascript
// 리액트, 자바스크립트 문법과 유사하며 null, undefined, false를 제외한 모든 값은 JSX에서 유효한 값이다.
// 자바스크립트 문법을 {}로 감싸면 JSX에서 자바스크립트 문법을 사용할 수 있으며, 리액트 외 다른 라이브러리에서도 사용할 수 있다.

{
  condition ? <div>Content to render when condition is true</div> : null;
}
```

**3. 비교적 배우기 쉽고 간결함**
앞의 두 가지 특징이 결합되어 리액트를 처음 접하는 사람들도 HTML과 자바스크립트를 알고 있다면 비교적 쉽게 배울 수 있다.
그러나 개발 초기에는 쉽지만, 이를 완벽히 이해하고 성능을 최적화하는 것은 상대적으로 어려운 축에 속한다. Vue나 최근에 나온 Svelte와 같은 프레임워크와 비교했을 때 프레임워크를 자유자재로 다루기까지 리액트는 상대적으로 시간이 걸린다.

**4. 강력한 커뮤니티, 메타(페이스북)**
리액트는 Angular와는 다르게 단순히 UI를 위한 라이브러리로만 작동함으로써 그 역할에 제한을 두고 그 외의 모든것에 자유도를 두었다.
개발자는 리액트를 기반으로 다양한 것을 시도할 수 있었고 그만큼 리액트는 커다란 커뮤니티를 형성할 수 있었다.

리액트는 단순히 현재 가장 많은 사람들이 웹 개발을 사용할 때 사용하는 라이브러리일 뿐, 가장 완벽하거나 가장 빠르거나 가장 합리적인 것은 아니다.

## 리액트의 역사

**프런트엔드 개발 환경을 향한 페이스북의 도전**
2000년대까지만 하더라도 웹 생태계는 LAMP스택이라고 하는, 리눅스Linux, 아파치Apache, MySQL, PHP로 구성된 스택이 주류를 이루었다.
이러한 웹 개발 패턴은 사용하는 프레임워크에 따라 조금씩 다르지만 대부분의 경우 서버에서 HTML을 생성하고, 클라이언트에서는 서버에서 생성한 HTML을 받아서 화면에 표시하는 방식이었다. 콘텐츠는 사용자나 기타 다른 환경에 따라 서버에서 동적으로 생성하고, 웹 브라우저는 이를 단순히 다운로드 받아 렌더링하며, 자바스크립트는 폼 처치와 같은 부수적인 역할만 하는 방식이었다.

2010년대에 들어서며 자바스크립트를 좀 더 편리하게 사용하기 위한 제이쿼리는 수많은 제이쿼르 플러그인과 함께 인기를 얻기 시작해 점차 자바스크립트의 비공식 표준으로 자리 잡았다.
이와 더불어 인터넷 익스플로러 8에서 등장한 로컬 스토리지, 2011년 공식적으로 표준으로 등록된 웹 소젯WebSocket, 자바스크립트로 그래픽을 표현할수 있게 해주는 캔버스Canvas, 벡터 그래픽을 표현할 수 있게 해주는 SVG, 사용자의 위치를 알 수 있는 Geolocation API, 사용자의 카메라와 마이크에 접근할 수 있게 해주는 getUserMedia API, 사용자의 파일을 읽을 수 있게 해주는 File API 등의 웹 표준이 등장하면서 웹 브라우저에서도 다양한 기능을 사용할 수 있게 되었으며, ES5가 처음으로 표준 스펙에 자리 잡았다.

이러한 브라우저와 생태계의 변화에 맞춰 서버에서 생성한 HTML 페이지를 보여주고 간단한 폼 처리 정도만 하던 브라우저 환경은 급변하기 시작했고, 자바스크립트는 적극적으로 DOM을 수정해 사용자에게 다양한 인터렉션을 보여주었고, AJAX를 통해 서버뿐만 아니라 클라이언트에서도 서버와 통신해 데이터를 불러오기 시작했다. 이에 따라 자바스크립트 코드가 점차 복잡해지기 시작했다.

이러한 필요성 때문에 구글에서는 Angular와 CoffeeScript, Underscore.js의 제작자 제레미 아쉬케나스가 선보인 Backbone.js였다.
두 프레임워크는 비슷한 시기에 등장했지만, Angular는 MVC(Model-View-Controller) 패턴을 따르고, Backbone.js는 MVVM(Model-View-ViewModel) 패턴을 따라 나날이 복잡해지는 자바스크립트 코드를 좀 더 효율적으로 관리할 수 있게 해주었다.

이 당시 페이스북은 약 7억명 정도의 사용자가 이용하는 전세계적인 소셜 네트워크 서비스였다. 많은 사용자가 이용하는 서비스이니만큼 성능은 무엇보다 중요했으며, 페이스북은 이를 위해 최대한 서버에서 렌더링하는 기술을 사용했고 자바스크립트의 번들의 크기를 줄이는데 오랜 기간 심혈을 기울였다.
그러나 페이스북 개발 팀이 자바스크립트 번들 사이즈를 최대한 줄이려고 노력했지만, 다양한 요구사항과 기능으로 인해 자바스크립트 코드의 복잡도는 점점 증가하기 시작했다. 이와 맞물려 페이스북에게 있어 웹의 중요성을 더욱 부각시킨 사건이 있었으니 바로 스파르탄 프로젝트였다.

스파르탄 프로젝트는 애플의 강력한 앱 규제에 반발해 만들어진 프로젝트로, 페이스북 iOS 앱 대신 애플의 사파리에서 작동할 수 있는 페이스북을 만들기 위해 추진되었다. 이를 통해 앱스토어에 등록할 필요가 없으며, 앱스토어의 규제에서 벗어날 수 있게 되는 것이었다. 또한 이 무렵 등장한 HTML5는 표준만 잘 지킨다면 PC나 모바일 환경에서 상관없이 모두 동일한 서비스를 제공할 수 있는 가능성을 제시했다.

하지만 앞으로 모든 애플리케이션을 HTML5로 만들어 하이브리드 앱으로 페이스북을 만들겠다는 스파르탄 프로젝트는 성공하지 못했다.
이는 네이티브로 만든 애플리케이션이 HTML5로 만든 것보다 훨씬 빠르고 안정적이었기 때문이다.

**BoltJS의 등장과 한계**
따라서 페이스북 팀은 그 당시 존재하던 다양한 옵션(바닐라 자바스크립트, 제이쿼리, Angular, Backbone.js)으로는 페이스북의 복잡한 요구사항을 처리하면서도 사용자에게 만족스러운 경험을 안겨주기 어렵다고 판단했으며 이에 따라 페이스북 팀은 자체적으로 프레임워크 BoltJS를 만들었다.

이 BoltJS는 깃허브를 통해 공개 되었지만 돌연 소스코드가 삭제되었으며 소스코드가 실제 프로덕션 서비스에서 사용되는 일은 없었다.
이에 따라 BoltJS를 개선할 필요성을 느낀 개발자들은 Functional Bolt, Fbolt라는 아이디어를 내놓았는데 이것이 바로 리액트의 시초가 되는 아이디어였다.
이름에서 알 수 있듯, 함수형을 지향하는 새로운 버전의 BoltJS였다.
이 당시 제안되었던 아이디어 중 하나는 애플리케이션에서 API의 변화에 따라 무언가 변경되면 단순히 UI를 초기화하고 새로 렌더링 하자는 것이었는데, 이 당시 이러한 접근법은 매우 혁신적이었다.

이 당시 대부분의 프레임워크는 양방향 다인딩 구조를 채택해 모델과 뷰가 밀접간 관계를 맺고 서로가 서로를 변경할 수 있는 구조였다. 이러한 방식은 대부분의 애플리케이션과 프레임워크에서 사용하던 방식으로, 코드를 작성하는 것은 간단하지만 변경된 DOM을 추적하는 것이 어렵고, 왜 이렇게 변경되었는지 역시 추적하기 어려워 수많은 버그가 발생하던 지점이기도 했다. 그런데 이러한 방식 대신, 모델이 뷰를 변경하는 단방향 방식으로 모델의 데이터가 변경되어 뷰가 변경되어야 하면 이전 DOM을 버리고 새롭게 렌더링하는 방식을 제안했다.
그러나 DOM의 변경을 최소한으로 하는 것이 성능을 위한 최선의 방법으로 여겨졌던 시기라 이러한 방식이 성능을 보장할 수 있을지 의구심을 푸믄 개발자들이 다수였다.

그러나 한편으로는 유용한 방식이었는데, 페이스북 프런트엔드 개발자들이 느꼈던 가장 큰 어려움은 DOM을 업데이트하는 것이었는데, '좋아요' 버튼의 클릭 이벤트 리스너를 등록하고, 이를 제거하고 다시 찾고, 다시 또 속성을 변경하는 작업은 매우 복잡했으며 버그의 주요 원인이었으며 개발자 스스로도 그 흐름을 이해하기 어려웠다.
이러한 상황에서 성능은 뒷전이 되었고, DOM을 새롭게 렌더링해 버리는 방식은 매우 유용한 방식이라고 생각되었으며 이에 따라 페이스북 팀은 이 방식을 채택하기로 결정했다.

**대안으로 떠오른 리액트**
리액트의 첫 번째 프로젝트는 게시물 하단에 있는 댓글, 공유 버튼이 있는 화면인 UFI(Universal Feedback Interface)였다.
사람들은 '좋아요'를 누르거나 댓글을 다는 행위 등이 모두 즉각적으로 이뤄지길 바랬으며, 이는 거의 채팅과 같은 반응 속도로 이뤄져야 했다. 그리고 이 UFI는 페이스북의 모든 페이지에 적용되어야 했으며, 이는 페이스북의 모든 페이지가 빠르게 렌더링되어야 한다는 것을 의미했다. 이러한 요구사항을 충족시키기 JSX 구문과 Flux 패턴에 대한 아이디어가 등장했다.

이렇게 리액트와 리액트를 기반으로 하는 프로젝트가 개발되고 있을 즈음 페이스북은 인스타그램을 인수했으며 그 당시 iOS와 안드로이드 버전밖에 없었지만, 페이스북은 인스타그램을 웹 버전으로도 제공하고 싶었다. 그러나 인스타그램은 페이스북과는 다른 기술 스택을 사용하고 있었으며, 이를 통합하는 것은 매우 어려운 일이었다. 이에 따라 페이스북은 인스타그램의 기술 스택을 페이스북과 동일하게 바꾸기로 결정했으며, 이를 위해 페이스북 팀은 리액트를 사용하기로 결정했다.

**리액트에 대한 회의적인 의견과 비판**
JSConf US 2013에서 공개된 리액트에 대한 반응은 그다지 좋지 못했다. 대다수의 개발자들은 JSX 구문의 특징, 자바스크립트 코드 내에 HTML을 추가한다는 것에 호의적이지 않았다.
HTML과 JS는 항상 다른 파일에 존재했고 이를 관심사 분리의 원칙을 지키기 위한 기초적인 사실로 받아들였기 때문에 그 당시 관점에서 JSX는 매우 이상한 방식이었다.

사실 리액트의 구조도 관심사 분리의 원칙을 따른다고 볼 수 있다. 당시의 관심사 분리는 HTML, 자바스크립트, CSS가 각기 다른 폴더와 파일로 분리되고, 파일의 역할별로 관심사가 분리되는 것에 초점을 맞췄지만, 리액트의 관심사 분리는 컴포넌트 기반으로 뉴스피드 컴포넌트의 JSX와 CSS, 사진의 JSX와 CSS, UFI의 JSX와 CSS로 나눠지는 등 컴포넌트의 역할에 따라 관심사가 분리되는 것에 초점을 맞추었다.
즉, 관심사 분리의 원칙이라는 개념하에 리액트와 기존 프런트엔드 프로젝트가 서로 다른 방식을 채택한 차이만 있을 뿐이었다.

**빛을 보는 리액트**
그러나 모두가 리액트에 대해 거부감을 느낀 것은 아니었다. 일부는 리액트의 접근 방식에 흥미를 느꼇으며 프로젝트에 리액트를 도입하기 시작했고, 리액트의 개발자가 아닌 외부 개발자들이 리액트에 새로운 아이디어와 활기를 불어 넣으면서 새로운 원동력을 찾기 시작했다. 이렇게 페이스북 밖의 오픈소스 컨트리뷰터들이 리액트에 새로운 아이디어를 제공하면서 리액트는 점점 성장해 나갔다.

리액트 커뮤니티는 리액트가 제공하지 못한 것을 채워주기 위해 상태 관리 라이브러리, 라우터 라이브러리, 서버 사이드 렌더링 프레임워크 등이 등장하기 시작하면서 리액트는 점점 프런트엔드 생태계에서 자리를 잡아가기 시작했다.

리액트를 체택한 유명한 웹 사이트 중 하나는 넷플릭스였다. 넷플릭스는 리액트를 사용하기 전 자바를 기반으로 만들었는데 많은 문제점들이 있었다. 최초 상호작용에는 평균 5초 정도 소요되었고, 웹 사이트 빌드는 20분 가까이 걸렸다. 무엇보다 기능을 추가하는 데도 매우 오랜 시간이 걸려 개발자들이 어려움을 겪었다.
이에 따라 넷플릭스 팀은 새로운 UI에 맞춰 새로운 웹 사이트를 만들고자 모던 프레임워크 도입을 고민하는데, 리액트를 염두에 뒀지만 당시 리액트가 페이스북 외에 성공한 사례가 부족해 확신을 가질 수 없어, 개발자를 두 팀으로 나눠 30일 동안 각각 리액트와 백본으로 웹 사이트를 만들어보기로 결정했다.
그 결과, 리액트가 몇 가지 더 확실한 장점을 가지고 있음을 깨닫게 된다.

1. 자바스크립트 코드의 크기가 줄었다.
   상태를 관리하기 위한 컨트롤러 대신, 리액트는 단지 상태에 따른 UI를 선언적으로 구현할 수 있었으므로 좀 더 간결하게 작성할 수 있었다.
   이러한 복잡성을 줄인 것만으로도 전체 코드의 크기를 확연하게 줄일 수 있었고, 그 결과 최초 상호작용에 걸리는 시간은 5초에서 1.5초로 줄었다.
2. 상대적으로 완만한 학습 곡선
   자바스크립트 코드와 HTML만 알면 손쉽게 리액트 코드를 작성할 수 있었다.
3. 빠른 기능 추가
   과거에는 새로운 기능을 보여주기 위해서는 사이트를 빌드하고 배포해야 했지만, 리액트는 자바 애플리케이션에 비해 기능을 추가하고 빌드하는 시간이 훨씬 빨랐다.

이러한 장점으로 넷플릭스는 새로운 UI를 가진 웹 사이트를 리액트로 작성했으며,
당시 전 세계에서 두 번째로 큰 IT 회사인 넷플릭스가 리액트 생태계에 뛰어들자 반신반의하던 프런트엔드 커뮤니티도 환호했다.
이와 비슷한 시기에 열린 React.js Conf가 성황리에 치러졌으며, 이 당시 소개된 라이브러리가 react-hot-loader, redux, react-router 등이었고 이는 리액트 성장을 더욱 가속화 했다.

**리액트의 현재와 미래**
2013년 5월 초 공개된 리액트의 버전은 0.3.0이고, 현재 2023년 12월 기준 최신 버전은 18.2.0이다.
앞서 언급한 것처럼 리액트는 현재 가장 인기있는 프레임워크로 자리 잡았다. Angular나 Vue 같은 다른 라이브러리와는 다르게, 웹 개발을 위한 프레임워크를 지향하지 않으므로 리액트와 함께 사용할 수 있는 다양한 라이브러리가 있다.

- 상태관리: Redux, MobX, Recoil, Zustand, Jotai
- 서버 사이드 렌더링: Next.js, Remix, Hydrogen
- 애니메이션: Framer Motion, React Spring, React Move
- 차트: Recharts, visx, nivo
- 폼: React Hook Form, Formik, React Final Form

이 밖에도 많은 라이브러리가 있으며 'react'라는 이름이나 태그를 가지고 있는 npm 패키지 또한 23만여개나 달한다.

React 개발자들이 밝힌 바에 따르면 이들이 현재 가장 집중적으로 역량을 쏟고 있는 것은 서버에서의 리액트 활용이다.
어떻게 하면 서버에서 리액트를 효율적으로 사용할 수 있을지, 그리고 이러한 전에 없던 작동 방식을 사용자에게 어떻게 소개할 수 있을지에 대한 고민을 하고 있다.

과거 리액트는 클라이언트에 초점을 맞추고 있었고, 앞으로도 브라우저와 클라이언트에서의 작동을 개선할 예정이라고 밝혔다. 그러나 리액트 팀은 서버에서의 리액트를 더욱 효율적으로 사용할 수 있도록 노력하고 있다. 따라서 앞으로 리액트를 계속 공부할 예정이라면 프런트엔드 개발자들도 Node.js 같은 서버 사이드 자바스크립트 런타임을 공부하는 것이 좋다.
